<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>this</title>
</head>
<body>
  <h1>이벤트 핸들러 내부의 this</h1>
  <p>
    어트리뷰트 방식의 경우 이벤트 핸들러에 의해 일반 함수로 호출 되고
    일반 함수 내부의 this는 전역 객체 window를 가리킨다.
    이벤트 핸들러 호출 시 인수로 전달한 this는 이벤트를 바인딩 한 DOM 요소를 가리킨다.
  </p>
  <button onclick="handleClick1()">클릭해보세요</button>
  <button onclick="handleClick2(this)">클릭해보세요</button>
  <script>
      function handleClick1() { console.log(this);}
      function handleClick2(param) { console.log(param);}
  </script>



  <p>
    이벤트 핸들러 프로퍼티 방식과
    addEventListener 방식 모두 이벤트 핸들러 내부의 this는
    이벤트를 바인딩 한 DOM 요소를 가리킨다.
  </p>
  <button id="btn1">클릭해보세요</button>
  <button id="btn2">클릭해보세요</button>

  <script>
      const $btn1 = document.querySelector('#btn1');
      const $btn2 = document.querySelector('#btn2');

      $btn1.onclick = function(e) { // 프로퍼티 방식
          // e == 이벤트 정보
          console.log(this); // == 이벤트 발생 객체(요소)
          console.log(e.currentTarget); // == 이벤트 발생 객체(요소)
      };

      $btn2.addEventListener('click', function(e){ // 이벤트 리스너 추가
          console.log(this);
          console.log(e.currentTarget);
      });
  </script>


  <p>
    화살표 함수로 정의한 이벤트 핸들러 내부의 this는 상위 스코프의 this를 가리킨다.
    화살표 함수 자체의 this바인딩을 가지지 않는다는 점에 유의한다.
  </p>

  <button id="btn3">클릭해보세요</button>
  <button id="btn4">클릭해보세요</button>
  <script>
      const $btn3 = document.querySelector('#btn3');
      const $btn4 = document.querySelector('#btn4');

      $btn3.onclick = (e) => {
          console.log(this);
          console.log(e.currentTarget);
      };

      $btn4.addEventListener('click', (e) => {
          console.log(this);
          console.log(e.currentTarget);
      });

      // 이벤트 핸들러 작성 시
      // 화살표 함수로 작성하면 this 사용 금지
      // 왜? 화살표 함수 밖 상위 객체(대부분 window)가 매핑된다
  </script>
</body>
</html>